{
  "hash": "82d3c6cf97244585fd4aee9a642c280f",
  "result": {
    "markdown": "---\ntitle: \"Advanced Text-As-Data <br> Winter School - Iesp UERJ\"\nsubtitle: \"<span style = 'font-size: 140%;'> <br> Day 1: Word Representation & Introduction to Neural Networks\"\nauthor: \"<span style = 'font-size: 120%;'> Professor: Tiago Ventura </span>\"\nexecute: \n  echo: false\n  error: true\n  cache: true\nformat:\n  revealjs: \n    transition: slide\n    background-transition: fade\n    code-line-numbers: false\n    width: 1400\n    height: 900\n    center: false\n    slide-number: true\n    incremental: true\n    chalkboard: \n      buttons: false\n    preview-links: auto\n    footer: \"Text-as-Data\"\n    theme: [simple, custom.scss]\neditor_options: \n  chunk_output_type: console\n---\n\n\n# Welcome to Advanced Text-as-Data: Introduction\n\n## Logistics\n\n- All materials will be here: https://tiagoventura.github.io/tad_iesp_workshop/ \n\n- Syllabus is more dense than we can cover in a week. Take your time to work through it!\n\n- Our time: Lectures in the afternoon, and code/exercises for you to work through at your time. \n\n- This is an advanced class in text-as-data. It requires:\n\n  - some background in programming, mainly Python\n  \n  - some notion of probability theory, particularly maximum likelihood estimation (LEGO III at IESP)\n  \n- You have a TA: Felipe Lamarca. Use him for your questions!\n\n- The classes are English, but feel free to ask questions in Portuguese if you prefer!\n\n## Our rules for a sucessful online workshop\n\n- We ask you to: \n\n  - Keep you cameras open\n  \n  - Ask questions throughout, feel free to interrupt us. \n  \n  - That's it!\n\n\n# Motivation\n\n## What is this class about?\n\n-   For many years, social scientists uses text in their empirical analysis:\n\n   - Close reading of documents.\n   - Qualitative Analysis of interviews\n   - Content Analysis\n   \n-   Digital Revolution:\n\n    -   Production of textual information increased with the internet.\n    \n    -  The capacity to store, access and share this large volume of data also increased.\n    \n    - At the same time, the cost of accessing large computing power reduced... think about your laptops...\n    \n    - And even powerful computational models (that do not fit in your laptop) became easily accessible. \n\n-   This class covers methods (and many applications) of using textual data and advanced computational linguistics model to [answer social science problems]{.red}\n\n- But... with an modern flavor. \n   \n   - Deep Learning Revolution / Large Language Models / Representation Learning. \n\n## Workshop Topics: \n\nWe will cover four topics: \n\n- Day 1: Motivation, Text Representation, and Introduction to Deep Learning\n\n- Day 2: Word embeddings\n\n- Day 3: Trasformer models\n\n- Day 4: Large Language Models.\n\n## Today\n\nToday, we will cover: \n\n- Text Representation. \n\n- Representation Learning & Distributional Semantics\n\n- Introduction to Deep Learning\n\n- Coding Practice: \n\n  - Neural Networks from Scratch. \n\n# Text Representation: From Sparse to Dense Vectors\n\n##  From Text to Numbers\n\n\n::: {.cell layout-align=\"center\" hash='day_1_cache/revealjs/unnamed-chunk-1_6a5c35105f7b46d0e11fb49b2dda2be9'}\n::: {.cell-output-display}\n![](figs/text_representation.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Vector Space Model\n\nTo represent documents as numbers, we will use the [vector space model representation]{.red}:\n\n-   A document $D_i$ is represented as a collection of features $W$ (words, tokens, n-grams..)\n\n-   Each feature $w_i$ can be place in a real line, then a document $D_i$ is a point in a $W$ dimensional space\n\n::: fragment\nImagine the sentence below: *\"If that is a joke, I love it. If not, can't wait to unpack that with you later.\"*\n\n-   **Sorted Vocabulary** =(a, can't, i, if, is, it, joke, later, love, not, that, to, unpack, wait, with, you\")\n\n-   **Feature Representation** = (1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1)\n\n-   Features will typically be the n-gram (mostly unigram) [frequencies]{.red} of the tokens in the document, or some [function]{.red} of those frequencies\n:::\n\n::: fragment\nNow each document is now a vector (vector space model)\n\n-   stacking these vectors will give you our workhose representation for text: [**Document Feature Matrix**]{.red}\n:::\n\n## Visualizing Vector Space Model\n\n::: {.callout-note icon=\"false\"}\n## Documents\n\nDocument 1 = \"yes yes yes no no no\"\n\nDocument 2 = \"yes yes yes yes yes yes\"\n:::\n\n\n::: {.cell layout-align=\"center\" hash='day_1_cache/revealjs/unnamed-chunk-2_f03dba4e4b7c89b6e8ccc47b51a3d86c'}\n::: {.cell-output-display}\n![](day_1_files/figure-revealjs/unnamed-chunk-2-1.png){fig-align='center' width=768}\n:::\n:::\n\n\n## Visualizing Vector Space Model\n\nIn the vector space, we can use geometry to build well-defined comparison measures between the documents \n\n\n::: {.cell layout-align=\"center\" hash='day_1_cache/revealjs/unnamed-chunk-3_c58496241982ac22855c2faacbc6718c'}\n::: {.cell-output-display}\n![](day_1_files/figure-revealjs/unnamed-chunk-3-1.png){fig-align='center' width=768}\n:::\n:::\n\n\n## Euclidean Distance\n\nThe *ordinary*, *straight line* distance between two points in space. Using document vectors $y_a$ and $y_b$ with $j$ dimensions\n\n::: {.callout-note icon=\"false\"}\n## Euclidean Distance\n\n$$\n||y_a - y_b|| = \\sqrt{\\sum^{j}(y_{aj} - y_{bj})^2}\n$$\n:::\n\n\n## Cosine Similarity\n\nEuclidean distance rewards [magnitude]{.red}, rather than [direction]{.red}\n\n$$\n\\text{cosine similarity}(\\mathbf{y_a}, \\mathbf{y_b}) = \\frac{\\mathbf{y_a} \\cdot \\mathbf{y_b}}{\\|\\mathbf{y_a}\\| \\|\\mathbf{y_b}\\|}\n$$\n\n[Unpacking the formula]{.red}:\n\n-   $\\mathbf{y_a} \\cdot \\mathbf{y_b}$ \\~ dot product between vectors\n\n    -   projecting common magnitudes\n    -   measure of similarity (see textbook)\n    -   $\\sum_j{y_{aj}*y_{bj}}$\n\n-   $||\\mathbf{y_a}||$ \\~ vector magnitude, length \\~ $\\sqrt{\\sum{y_{aj}^2}}$\n\n-   normalizes similarity by documents' length \\~ independent of document length be because it deals only with the [angle of the vectors]{.red}\n\n-   cosine similarity captures some notion of relative *direction* (e.g. style or topics in the document)\n\n##  Workhorse Representation: Document-Feature Matrix\n\n\n::: {.cell layout-align=\"center\" hash='day_1_cache/revealjs/unnamed-chunk-4_f2b50e4c1d31d5bafb6a0a7b72b8616b'}\n::: {.cell-output-display}\n![](figs/DTM.png){fig-align='center' width=100%}\n:::\n:::\n\n\n::: aside\nSource: [Arthur Spirling TAD Class](https://github.com/ArthurSpirling/text-as-data-class-spring2021)\n:::\n\n## Vector Space Model vs Representation Learning\n\nThe vector space model is super useful, and has been used in many many many applications in computational linguistics and social science applications of text-as-data. Including:\n\n- Descriptive statistics of documents (count words, text-similarity, complexity, etc..)\n\n- Supervised Machine Learning Models for Text Classification (DFM becomes the input of the models)\n\n- Unsupervised Machine Learning (Topic Models & Clustering)\n\n\n::: fragment\n\n**But**... Embedded in this model, there is the idea we represent [words]{.red} as a [one-hot encoding]{.red}.\n\n-   \"cat\": \\[0,0, 0, 0, 0, 0, 1, 0, ....., V\\] , on a V dimensional vector\n-   \"dog\": \\[0,0, 0, 0, 0, 0, 0, 1, ...., V\\], on a V dimensional vector\n:::\n\n::: fragment\n**What these vectors look like?**\n\n-   really sparse\n\n-   those vectors are orthogonal\n\n-   no natural notion of similarity\n:::\n\n# How can we embed some notion of similarity in the way we represent words?\n\n## Distributional Semantics\n\n> \"you shall know a word by the company it keeps.\" J. R. Firth 1957\n\n[Distributional semantics]{.red}: words that are used in the same contexts tend to be similar in their meaning.\n\n::: incremental\n-   How can we use this insight to build a word representation?\n\n    -   Move from sparse representation to dense representation\n\n    -   Represent words as vectors of numbers with high number of dimensions\n\n    -   Each feature on this vectors embeds some information from the word (gender? noun? sentiment? stance?)\n\n    -   Learn this representation from the unlabeled data.\n:::\n\n## Sparse vs Dense Vectors\n\n:::noincremental \n\n**One-hot encoding / Sparse Representation:**\n\n-   cat = $\\begin{bmatrix} 0,0, 0, 0, 0, 0, 1, 0, 0 \\end{bmatrix}$\n\n-   dog = $\\begin{bmatrix} 0,0, 0, 0, 0, 1, 0, 0, 0 \\end{bmatrix}$\n\n**Word Embedding / Dense Representation:**\n\n-   cat = $\\begin{bmatrix} 0.25, -0.75, 0.90, 0.12, -0.50, 0.33, 0.66, -0.88, 0.10, -0.45 \\end{bmatrix}$\n\n-   dog = $\\begin{bmatrix} 0.25, 1.75, 0.90, 0.12, -0.50, 0.33, 0.66, -0.88, 0.10, -0.45 \\end{bmatrix}$\n:::\n\n## With colors and real word vectors\n\n\n::: {.cell hash='day_1_cache/revealjs/unnamed-chunk-5_0bb2b432394cb8a74c682f6692328990'}\n::: {.cell-output-display}\n![](./week7_figs/embed_color.png){width=70%}\n:::\n:::\n\n\nSource: [Illustrated Word2Vec](https://jalammar.github.io/illustrated-word2vec/)\n\n\n## Word Embeddings\n\n- **Encoding similarity:** vectors are not ortogonal anymore!\n\n- **Automatic Generalization:** learn about one word allow us to automatically learn about related words\n\n- **Encodes Meaning:** by learning the context, I can learn what a word means.\n\n- **As a consequence:**\n\n   -   Word Embeddings improves by ORDERS OF MAGNITUDE several Text-as-Data Tasks.\n\n   -   Allows to deal with unseen words.\n\n   -   Form the core idea of state-of-the-art models, such as LLMs.\n\n## Deep Learning for Text Analysis\n\n\n::: {.cell hash='day_1_cache/revealjs/unnamed-chunk-6_823212f1bc4ef2c52e976a703478feca'}\n::: {.cell-output-display}\n![](./figs/deep_learning.png){width=70%}\n:::\n:::\n\n\n# Introduction to Deep Learning\n\n## Basics of Machine Learning\n\n**Deep Learning** is a subfield of machine learning based on using neural networks models to learn.\n\nAs in any other statistical model, the goal of machine learning is to use data to learn about some output. \n\n$$ y = f(X) + \\epsilon$$\n\n- **Where:**\n\n -   $y$ is the outcome/dependent/response variable\n\n -   $X$ is a matrix of predictors/features/independent variables\n\n -   $f()$ is some fixed but unknown function mapping X to y. The \"signal\" in the data\n\n -   $\\epsilon$ is some random error term. The \"noise\" in the data.\n\n\n## Linear models (OLS)\n\nThe simplest model we can use is an linear model (the classic OLS regression)\n\n$$ y = b_0 + WX + \\epsilon$$\n\n- Where: \n\n  - $W$ is a vector of dimension p, \n  - $X$ is the feature vector of dimension p\n  - $b$ is a bias term (intercept)\n\n## Using Matrix Algebra\n\n$$\\mathbf{W} = \\begin{bmatrix} w_1 & w_2 & \\dots & w_p\\end{bmatrix}$$\n\n\n$$\\mathbf{X} = \\begin{bmatrix} X_1 \\\\ X_2 \\\\ X_3 \\\\ \\vdots \\\\ X_p \\end{bmatrix}$$\n\nWith matrix multiplication:\n\n$$\\mathbf{W} \\mathbf{X} + b = w_1 X_1 + w_2 X_2 + \\dots + w_p X_p + b$$\n\n## Logistic Regression\n\nIf we want to model some type of non-linearity, necessary for example when our outcome is binary, we can add a transformation function to make things non-linear:\n\n$$ y = \\sigma (b_0 + WX + \\epsilon)$$\n\nWhere: \n\n$$ \\sigma(b_0 + WX + \\epsilon) = \\frac{1}{1 + \\exp(-b_0 + WX + \\epsilon)}$$\n\n## \n\n\n::: {.cell hash='day_1_cache/revealjs/unnamed-chunk-7_9c17d8c3de5c13f44e879154fde24343'}\n::: {.cell-output-display}\n![](./figs/sigmoid.png){width=100%}\n:::\n:::\n\n\n## Logistic Regression as a Neural Network\n\nAssume we have a simple model of voting. We want to predict if individual $i$ will vote ($y=1$), and we will use four socio demographic factors to make this prediction. \n\nClassic statistical approach with logistic regression: \n\n$$ \\hat{P(Y_i=1|X)} = \\sigma(b_0 + WX + \\epsilon) $$\nWe use MLE (Maximum Likelihood estimation) to find the parameters $W$ and $b_0$. We assume:\n\n$$ Y_i \\sim \\text{Bernoulli}(\\pi_i) $$\n\nThe likelihood function for $n$ independent observations is:\n\n$$L(W, b_0) = \\prod_{i=1}^{n} \\pi_i^{y_i} (1 - \\pi_i)^{1 - y_i}.$$\n\n\n## Neural Network Graphical Representation\n\n\n::: {.cell hash='day_1_cache/revealjs/unnamed-chunk-8_1cdefc985df8b90076837379cea1cbf6'}\n::: {.cell-output-display}\n![](./figs/nn.png){width=100%}\n:::\n:::\n\n\n::: aside\nSource: https://carpentries-incubator.github.io/ml4bio-workshop/05-logit-ann/index.html\n:::\n\n## Deep Neural Networks\n\nA **Deep Neural Network** is equivalent to stacking multiple logistic regressions vertically and repeat this process multiple times across many layers.\n\nAs a Matrix, instead of: \n\n$$\\mathbf{W}_{previous} = \\begin{bmatrix} w_1 & w_2 & \\dots & w_p\\end{bmatrix}$$\n\n\nWe use this set of parameters: \n\n$$\n\\mathbf{W} = \\begin{bmatrix} w_{11} & w_{12} & w_{13} & \\dots & w_{1p} \\\\\n                               w_{21} & w_{22} & w_{23} & \\dots & w_{2p} \\\\\n                               w_{31} & w_{32} & w_{33} & \\dots & w_{3p} \\\\\n                               \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n                               w_{k1} & w_{k2} & w_{k3} & \\dots & w_{kp}\n                \\end{bmatrix}\n$$                \n\n\n## \n\nThen, every line becomes a different logistic regression\n\n$$\\mathbf{WX} = \\begin{bmatrix}  \\sigma(w_{11} X_1 + w_{12} X_2 + \\dots + w_{1p}X_p) \\\\ \\sigma(w_{21} X_1 + w_{22} X_2 + \\dots + w_{2p}X_p) \\\\ \\sigma(w_{31} X_1 + w_{32} X_2 + \\dots + w_{3p}X_p )\\\\ \\vdots \\\\ \\sigma(w_{k1} X_1 + w_{k2} X_2 + \\dots + w_{kp}X_p) \\end{bmatrix}$$\nWe then combine all of those with another set of parameters: \n\n$$\n\\begin{align*}\n    \\mathbf{HA} &= h1 \\cdot \\sigma(w_{11} X_1 + w_{12} X_2 + \\dots + w_{1p}X_p)\\\\\n                &+ h_2\\cdot \\sigma(w_{21} X_1 + w_{22} X_2 + \\dots + w_{2p}X_p)\\\\\n                &+ h_3 \\cdot \\sigma (w_{31} X_1 + w_{32} X_2 + \\dots + w_{3p}X_p)\\\\\n                &+ \\dots + h_k + \\sigma(w_{k1} X_1 + w_{k2} X_2 + \\dots + w_{kp}X_p)\n\\end{align*}\n$$\n\n## Feed Forward on a Deep Neural Network\n\n\n::: {.cell hash='day_1_cache/revealjs/unnamed-chunk-9_46fbf73e91efbdad698b2a795a3b97ed'}\n::: {.cell-output-display}\n![](./figs/feed_forward.png){width=100%}\n:::\n:::\n\n\n## Key Components \n\n- Input: p features (the original data) of an observation are linearly transformed into k1 features using a weight matrix of size k1×p\n\n- Embedding Matrices: Paremeters you multiply your data by. \n\n- Neurons: Number of dimensions on your embedding matrices\n\n- Hidden Layer: the transformation that consists of the linear transformation and an activation function\n\n- Output Layer: the transformation that consists of the linear transformation and then (usually) a sigmoid (or some other activation function) to produce the final output predictions\n\n##\n\n![](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExYmY4dWFlNDgzM3FiY3RnM3ZweXZyejBpcjM2c291cWduZnhoYjVudCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/lJnAXeJO8tE7E37mxq/giphy.gif)\n\n\n## Let's take a step back! \n\nWeights matrices are just parameters... the $\\beta_s$ of our regression models. \n\n- There are too MANY of them!! Neural Networks are a black box!\n\n- But... they also serve as way to project covariates (or words!) in a dense dimensional space.\n\n- Remember: \n\n   - **One-hot encoding / Sparse Representation:**\n\n      -   cat = $\\begin{bmatrix} 0,0, 0, 0, 0, 0, 1, 0, 0 \\end{bmatrix}$\n\n      -   dog = $\\begin{bmatrix} 0,0, 0, 0, 0, 1, 0, 0, 0 \\end{bmatrix}$\n\n   - **Word Embedding / Dense Representation:**\n\n      -   cat = $\\begin{bmatrix} 0.25, -0.75, 0.90, 0.12, -0.50, 0.33, 0.66, -0.88, 0.10, -0.45 \\end{bmatrix}$\n\n      -   dog = $\\begin{bmatrix} 0.25, 1.75, 0.90, 0.12, -0.50, 0.33, 0.66, -0.88, 0.10, -0.45 \\end{bmatrix}$\n\n\n## Deep Neural Network for Textual Data\n\n\n::: {.cell hash='day_1_cache/revealjs/unnamed-chunk-10_014c907f37d275cfb0634aa30bbe4237'}\n::: {.cell-output-display}\n![](./figs/nlp_nn.png){width=100%}\n:::\n:::\n\n\n\n## Estimation: How do get good parameters?\n\nTo estimate the parameters, we will use a algorithm called Gradient Descent. As in any other estimation, we start definition \n\n**Linear Regression: MSE**\n\n$$\\text{RSS} = \\sum_{i=1}^{n} (y_i - \\widehat{y}_i)^2 $$\n\n\n**Logistic Regression: Negative Log Likelihood of a Bernouli distribution**\n\n$$L(\\beta) = -\\sum_{i=1}^{n} \\left( y_i \\log(\\widehat{y}_i) + (1-y_i)\\log(1 - \\widehat{y}_i) \\right)$$\n\n**Fully-Connected Neural Network (Classification, Binary): bBinary Cross Entropy**\n\n$$L(\\mathbf{W}) = -\\frac{1}{n}\\sum_{i=1}^{n} \\left( y_i \\log(\\widehat{y}_i) + (1-y_i)\\log(1 - \\widehat{y}_i) \\right)$$\n\n\n##\n\n\n\n::: {.cell hash='day_1_cache/revealjs/unnamed-chunk-11_293f08015dd5f8aa4850ad8fc4cab243'}\n::: {.cell-output-display}\n![](./figs/loss.png){width=100%}\n:::\n:::\n\n\n\n## Updating parameters\n\n- Define a loss function\n\n- Gradient Descent Algorithm: \n\n   - Initialize weights randomly\n   \n   - Feed Forward: Matrix Multiplication + Activation function\n   \n   - Get the loss for this iteration\n   \n   - Compute gradient (partial derivatives): $\\frac{\\partial J(\\mathbf{W})}{\\partial \\mathbf{W}}$\n\n   \n   - Update weights: $W_{new}: W_{old} -\\eta \\cdot \\frac{\\partial J(\\mathbf{W})}{\\partial \\mathbf{W}}$\n\n   - Loop until convergence:\n\n# Code!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}